# Documentación del proceso de aprendizaje a lo largo del curso
Como parte del trabajo final de la asignatura Periodismo de datos, hemos de documentar todo nuestro proceso de aprendizaje a lo largo de las semanas que ha durado el curso, desde que instalásemos el emulador de la terminal de Linux (en mi caso, Ubuntu y, posteriormente, Cygwin), hasta su uso vinculado con Github, los diferentes comandos aprendidos y otras aplicaciones y lenguajes.

## Instalación del programa de emulación de la terminal
El primer paso que tuvimos que llevar a cabo fue instalar un emulador de la terminal de Linux en nuestros ordenadores. En mi caso, usuaria de Windows, hice lo siguiente. Entré en la Windows Power Shell y con el comando, opciones y argumento `wsl -- install -d Ubuntu` descargué el emulador Ubuntu.

Más adelante en el curso también instalamos Cygwin para usarlo con la misma función que usabamos Ubuntu. Cygwin es un emulador de Unix para Windows. A diferencia de Ubuntu, lo hemos descargado directamente de la web. Ejecutamos el archivo `setup-x86_64.exe` para instalarlo en nuestro ordenador. Una vez lo hayamos hecho, nos preguntará si queremos instalar paquetes antes de culminar la instalación de la aplicación en sí. Hemos instalado `libcurl14`, `wget`, `ca-certificates-letsencrypt`, `linx`, `nano`y `openssl`. 

## Configuración de un programa de edición de texto
Para editar nuestros textos hemos usado nano desde el emulador de la terminal. En nano, por defecto, cada línea es un párrafo, así que la visualización no era muy cómoda (porque solemos hacer párrafos más largos que el ancho de una pantalla). Lo solucionamos añadiendo el "linesoftwrap" al archivo de configuración.

Para hacerlo, tenemos que ubicar dicho archivo de configuración. Usamos `echo $HOME`. HOME es una variable de entorno (por eso va precedida de $) del lugar de inicio, el entorno de usuario. `echo` es un comando que nos devuelve en pantalla el argumento que hemos especificado. Te devuelve cuál es tu $HOME, en mi caso,"/home/raquelsg". Con `env` podemos todas las variables de entorno que tenemos (hicimos `env|less` para leerlas mejor).

Ubicamos el archivo de configuración (nano.rc) y lo abrimos con nano para editarlo: `nano/home/raquelsg/ .nano.rc`. Allí escribimos las dos cosas que queremos que se configuren para nano: `set softwrap` y `set linenumbers`. Podemos añadir en otra línea con una # un comentario que explique que hace cada una, respectivamente, ajustar el texto a pantalla y numerar las líneas. 

### Markdown
En nano vamos a usar la sintaxis simple de Markdown, un lenguaje estructurado. Así aprendemos que # sirve para poner un título (## un subtítulo; ### un título a un nivel jerárquicamente inferior...). El texto entre ** ** es *strong*, importante, lo que comunmente conocemos como "negrita" y * * podrá el texto en cursiva. Más adelante aprenderemos también a generar hipervínculos y visualizar imágenes. Con `[]`señalamos el texto que queremos que se muestre y a continuación, entre `()`la url vinculada. Para las imágenes es lo mismo colocando `!` al principio del todo y dando como resultado final. También creamos listas desordenadas con - y ordenadas con 1, 2, etc. 

## Configuración del programa
Primero, conocemos la existencia de un manual de uso abrimos "man" (el manual de uso) con `more`(saldrá esta opción por defecto), que permite visualizarlo (no editarlo) por páginas. Para visualizarlo línea línea podemos usar `less`. Escribimos man ls|less".  Podemos usarlo si tenemos dudas no solo en la configuración del programa, sino también para los comandos que explicaremos en un punto posterior del presente documento.

Para la configuración del programa hemos hecho varias cosas relevantes. La más importante fue configurar git. En el caso de Cygwin, también es importante mencionar el cambio de la *home* a la de Windows. Por último, explicaremos cómo establecimos un alias equivalente a la ruta de nuestro directorio de trabajo. 

### Configuración de git
Este paso fue vital para la realización de las diferentes prácticas que hemos llevado a cabo enlazadas en [el README](README.md). Configuramos git para poder hacer cambios en nuestro ordenador y vincularlos con nuestro respositorio de Github (online), sirviéndonos también de varios comandos que se explican en una parte posterior del presente documento. 

Para configurar nuestro usuario de git en el emulador de la terminal usaremos el comando `git config`. Ejecutaremos este comando dos veces usando diferentes opciones (y consiguientes argumentos). El primero es `--global user.name`, cuyo argumento será nuestro usuario en Github (en mi caso, "RaquelSG99"). Para `--global user.email` escribimos el correo electrónico con el que nos hemos dado de alta en Github (en mi caso "100386128@alumnos.uc3m.es").

En el caso de que ubiésemos hecho algún commit (se explica lo que es en el apartado "comandos" de este documento) antes de configurar git, lo solucionamos con `git commit --amend --reset author` y una vez hecho esto seguimos los pasos anteriores normalmente.

### Cambiar "home" de Cygwin
Mencionamos al explicar la instalación de Ubuntu y Cygwin que este, a diferencia del primero, es externo a Windows. Por ello, en el caso de Cygwin tuvimos que cambiar su *home* a la de nuestro usuario de Windows. 
Con `nano` editamos `/etc/nsswith.conf`, en el que escribimos `db_home: windows`. 

### Creación del alias *micasa*
Como ya adelantábamos, creamos un alias equivalente a la ruta donde guardamos todos los archivos relacionados con la asignatura, en mi caso `/mnt/c/Users/Raquel Suárez Gago/Mis Documentos/PERIHUM/2do cuatri/Periodismo de datos/apuntes-periodismo-datos`. Claramente, es muy larga, y sería mucho más cómodo que pudiendo escribir algo más corto nos llevase directamente a ese directorio. Siguiendo los pasos que detallamos a continuación, será posible escribiendo tan solo `micasa`.

Para establecer un alias tenemos que editar el archivo de configuración de Bash en `$HOME/.bashrc`. Lo abrimos con nano (igual que hicimos en el apartado anterior) para editarlo y así agregar el alias al archivo de configuración de bash. Una vez en él usaremos escribimos `"echo alias micasa="cd'/mnt/c/Users/Raquel Suárez Gago/Mis Documentos/PERIHUM/2do cuatri/Periodismo de datos/apuntes-periodismo-datos'" >> $HOME/.bashrc`. Salimos y volvemos a entrar en el emulador de la terminal y ya debería funcionar.

## Configuración y funcionamiento de un gestor de paquetes/programas del emulador de la terminal
Un gestor de paquetes *mantiene un resgistro del software que está instalado en su ordenador y le permite instalar un software nuevo, actualizarlo a versiones más recientes o eliminar software de una manera sencilla* [Fuente:debian.org](https://www.debian.org/doc/manuals/aptitude/pr01s02.es.html#:~:text=%C2%BFQu%C3%A9%20es%20un%20gestor%20de%20paquetes%3F%20Un%20gestor,recientes%2C%20o%20eliminar%20software%20de%20una%20manera%20sencilla.). El de Ubuntu es `apt`y el de Cygwin `apt-cyg`. 

Como ya adelantábamos al explicar la instalación de Cygwin, nos preguntó si queríamos añadir algunos paquetes. Eran necesarios para configurar estos gestores de paquetes y programas. Instalamos el gestor de paquetes con `lynx -source rawgit.com/transcode-open/apt-cyg/master/apt-cyg > apt-cyg` y después ejecutamos `install apt-cyg /bin`. Para instalar programas hacemos `apt-cyg install` y como argumento lo que queramos instalar, por ejemplo, nano: `apt-cyg install nano`. 

## Versión del lenguaje de SHELL utilizado
El lenguaje de SHELL que hemos utilizado es Bash. Podemos comprobarlo con `echo $0`(`echo`para que devuelva el texto a pantalla y `$`porque es una variable de entorno). Para comprobar más específicamente qué versión de Bash estamos usando podemos hacer, siguiendo la misma lógica, `echo $BASH_VERSION`. En Ubuntu es `5.0.17(1)-release`; en Cygwin `4.4.12(3)-release`.

## Valor de la variable de entorno PATH
PATH es una variable de entorno `$PATH`en la que se especifican las rutas en las que el intérprete de comandos busca los programas que tiene que ejecutar. Si hacemos `echo $PATH` veremos exactamente cuáles incluye. 

## Comandos utilizados y ejemplos
A continuación detallamos los principales comandos que hemos usado a lo largo del curso.
- `whoami`: quién soy. Nos devuelve nuestro usuario. El mío es "raquelsg".
- `echo`: devuelve texto en pantalla. Lo usamos por ejemplo para saber cuál es nuestra `$HOME`o `$PATH`: nos devolvía esos datos (por ejemplo, mi `$HOME`es `/home/raquelsg`).
- `pwd`: print work directory. Nos "imprime el directorio de trabajo", lo que nos sirve para saber dónde estamos trabajando, en qué "lugar de nuestro ordenador"nos encontramos. Lo hemos utilizado continuamente a lo largo de la asignatura para ubicarnos y ver si estamos trabajando en el directorio correcto (normalmente nuestra carpeta clonada de Github) que contenga los archivos a los que necesitemos acceder o donde queramos crear nuevos. El comando nos devuelve la ruta (en mi caso, en el ejemplo anterior, "/mnt/c/Users/Raquel Suárez Gago/Mis Documentos/PERIHUM/2do cuatri/Periodismo de Datos/RaquelSG99", usamos las comillas para evitar problemas con espacios y otros caracteres).
- `ls`: list. Nos "lista" (nombra) el contenido del directorio en el que nos encontremos: los documentos o carpetas que contenga y a los que podemos seguir acccediendo partiendo de esa ruta. Es muy útil para llegar al directorio final al que queramos llegar paso a paso (por ejemplo, en el caso anterior, si yo estoy en "/mnt/c/Users/Raquel Suárez Gago/Mis Documentos/PERIHUM/2do cuatri/Periodismo de datos/RaquelSG99" puedo hacer `ls`y veré que esa carpeta contiene todas mis prácticas de la asignatura, que puedo abrir con el comando que explicaremos justo a continuación). También es útil para comprobar que algo se ha descargado o copiado bien (podríamos hacerlo después de usar el comando `cp` que explicaremos en otro momento). Este comando también tiene la opción `-l`, una versión "larga" del listado que especifica algunas de sus características.
- `cd`: change directory. Sirve, como su propio nombre indica, para cambiar de directorio respecto al directorio de trabajo (lo sabemos con `pwd`) en el que estemos previamente. Hay que tener en cuenta la estructura arborea, por eso es importante usar `ls` para ver que argumentos podemos añadir a `cd` dentro de la ruta en la que estamos.
- `mkdir`: make directory. Con este comando creamos un nuevo directorio (carpeta). El argumento que le sigue será el nombre de ese nuevo directorio. Por ejemplo hicimos `mkdir github` para crear una carpeta dentro de la ruta "/mnt/c/Users/Raquel Suárez Gago/Mis Documentos/PERIHUM/2do cuatri/Periodismo de datos" donde guardar nuestras primeras prácticas hasta que aprendimos a vincular el ordenador con github (yo, personalmente, después la eliminé y cloné el repositorio de Github directamente en el directorio "Periodismo de datos" para no alargar más la ruta). Con `&&`se pueden ejecutar dos comandos sucesivos. Cuando creamos el directorio "github" hicimos `mkdir github && cd github`para que nos cambiase a ese directorio y que seguir trabajando en él.
- `cat`: concatenar. Permite crear fusionar e imprimir archivos para visualizarlos en pantalla. Lo usamos antes de tener nano para editar nuestros textos.
- `nano`: nano es un comando y un editor de texto que te permite crear y modificar archivos. El argumento es el nombre del archivo que vamos a crear o modificar si ya existía (en este caso, se tiene que ubicar en la ruta de nuestro directorio de trabajo). Trabajamos con markdown, que es importante que termine en ".md". Por ejemplo, para crear (y posteriormente editar) este documento que estoy escribiendo escribí `nano resumen.md`. 
- `mv`: move, mover. Los argumentos serán el origen y el destino. Traslada un archivo o directorio de una ruta a otra. Podemos usar un punto para indicar el lugar en el que estamos (lo sabemos con `pwd`, nos referimos a nuestro directorio de trabajo). Entre origen y destino dejamos un espacio en blanco y separamos todo con `/`porque trabajamos con rutas. Es decir, sería: `mv /origen/ /destino/`. Los archivos o directorios de origen desaparecen porque ahora se ubican en destino. 
- `cp`: copy, copiar. Igualmente, los argumentos son origen y destino, la estructura es la misma que para `mv`. Funciona como `mv`pero en este caso duplica lo que estamos copiando (es decir el archivo/carpeta se mantiene en origen). Es lo que hemos hecho cuando hemos clonado el nuevo repositorio dentro de "Pontedatos". Copimos las prácticas que habíamos realizado y teníamos guardadas en la carpeta clonada de nuestro repositorio en el perfil personal a la nueva carpeta clonada dentro de "Pontedatos".
- `rm`: remove, borrar. Elimina un archivo o directorio (como argumento escribimos el nombre de ese archivo o directorio que queremos borrar).
- `git clone`: sirve para clonar un repositorio en remoto, de tal manera que queda vinculado con nuestro ordenador. Nosotros hemos clonado nuestro repositorio en Github (el del perfil personal y el de Pontedatos) para vincularlo con nuestro ordenador y editar/crear las prácticas con nano en el emulador de la terminal para después actualizarlas en Github desde este mismo. El argumento del comando es el link del repositorio que queremos clonar. Se crea en nuestro ordenador una "copia" (en el directorio de trabajo en el que ejecutamos el comando) de aquello que hemos clonado. Con los comandos que explicaremos a continuación es con los que los cambios que hacemos desde la terminal se actualizan en la url del repositorio clonado.
- `git add`: añadir. Este comando añade los cambios que hemos realizado en remoto para su posterior actualización en Github. Como argumento, tenemos que especificar qué queremos exactamente que se añada (nombre del/de los archivo/s). Nosotros solemos utilizar ` .` para indicar que queremos añadir los cambios de los archivos del directorio de trabajo en el que estamos en ese momento (ya que todo lo hacemos en su carpeta correspondiente). Lo haremos, por ejemplo, una vez terminado de redactar este mismo documento para vincularlo a nuestro repositorio en Pontedatos (igual que los dos pasos siguientes). 
- `git commit`: guarda lo que hemos añadido con git add; es el siguiente paso previo a actualizar los cambios en Github. Lo acompañamos de la opción `-m` de "message", mensaje, para indicar en qué consiste el cambio que hemos realizado. El argumento será (entrecomillas si usamos espacios, tildes, etc. para evitar errores) el nombre que damos a ese cambio. Por ejemplo, uno de mis últimos commits ha sido corregir algunos errores que había cometido en la práctica 3, así que tras editarlos con nano y hacer `git add .` hice git commit con `git commit -m 'correccion-p3'`. 
- `git push`: git push es el último paso para actualizar los cambios en Github (push, "empujar" es porque manda esos cambios a la url vinculada). Simplemente tenemos que ejecutar el comando. Nos pedirá nuestro usuario (RaquelSG99) y contraseña (un token que tenemos que generar previamente) para ejecutarlo.
- `git status`: nos informa de cuál es el estado de nuestro git si estamos perdidos en los pasos anteriores. Si se han guardado cambios, pero falta commitear, si ya está todo listo para ejecutar `git push`, cuáles son los cambios en remoto que no se han vinculado a la web... 
