ME QUEDE REVISANDO EN P.23 CUANDO HICIMOS EL ALIAS

# Documentación del proceso de aprendizaje a lo largo del curso
Como parte del trabajo final de la asignatura Periodismo de datos, hemos de documentar todo nuestro proceso de aprendizaje a lo largo de las semanas que ha durado el curso, desde que instalásemos el emulador de la terminal de Linux (en mi caso, Ubuntu y, posteriormente, Cygwin), hasta su uso vinculado con Github, los diferentes comandos aprendidos y otras aplicaciones y lenguajes.

## Instalación del programa de emulación de la terminal
El primer paso que tuvimos que llevar a cabo fue instalar un emulador de la terminal de Linux en nuestros ordenadores. En mi caso, usuaria de Windows, hice lo siguiente. Entré en la Windows Power Shell y con el comando, opciones y argumento `wsl -- install -d Ubuntu` descargué el emulador Ubuntu.

## Configuración del programa
Primero, conocemos la existencia de un manual de uso abrimos "man" (el manual de uso) con `more`(saldrá esta opción por defecto), que permite visualizarlo (no editarlo) por páginas. Para visualizarlo línea línea podemos usar `less`. Escribimos man ls|less".

## Configuración de un programa de edición de texto
Para editar nuestros textos hemos usado nano desde el emulador de la terminal. En nano, por defecto, cada línea es un párrafo, así que la visualización no era muy cómoda (porque solemos hacer párrafos más largos que el ancho de una pantalla). Lo solucionamos añadiendo el "linesoftwrap" al archivo de configuración.
Para hacerlo, tenemos que ubicar dicho archivo de configuración. Usamos `echo $HOME`. HOME es una variable de entorno (por eso va precedida de $) del lugar de inicio, el entorno de usuario. `echo` es un comando que nos devuelve en pantalla el argumento que hemos especificado. Te devuelve cuál es tu $HOME, en mi caso,"/home/raquelsg". Con `env` podemos todas las variables de entorno que tenemos (hicimos `env|less` para leerlas mejor).
Ubicamos el archivo de configuración (nano.rc) y lo abrimos con nano para editarlo: `nano/home/raquelsg/ .nano.rc`. Allí escribimos las dos cosas que queremos que se configuren para nano: `set softwrap` y `set linenumbers`. Podemos añadir en otra línea con una # un comentario que explique que hace cada una, respectivamente, ajustar el texto a pantalla y numerar las líneas. 
### Markdown
En nano vamos a usar la sintaxis simple de Markdown, un lenguaje estructurado. Así aprendemos que # sirve para poner un título (## un subtítulo; ### un título a un nivel jerárquicamente inferior...). El texto entre ** ** es *strong*, importante, lo que comunmente conocemos como "negrita" y * * podrá el texto en cursiva. Más adelante aprenderemos también a generar hipervínculos y visualizar imágenes. Con `[]`señalamos el texto que queremos que se muestre y a continuación, entre `()`la url vinculada. Para las imágenes es lo mismo colocando `!` al principio del todo y dando como resultado final. También creamos listas desordenadas con - y ordenadas con 1, 2, etc. 

## Configuración y funcionamiento de un gestor de paquetes/programas del emulador de la terminal

## Versión del lenguaje de SHELL utilizado
Bash

## Valor de la variable de entorno PATH
PATH es una variable de entorno `$PATH`en la que se especifican las rutas en las que el intérprete de comandos busca los programas que tiene que ejecutar. Si hacemos `echo $PATH` veremos exactamente cuáles incluye. 

## Comandos utilizados y ejemplos
A continuación detallamos los principales comandos que hemos usado a lo largo del curso.
- `whoami`: quién soy. Nos devuelve nuestro nombre.
- `pwd`: print work directory. Nos "imprime el directorio de trabajo", lo que nos sirve para saber dónde estamos trabajando, en qué "lugar de nuestro ordenador"nos encontramos. Lo hemos utilizado continuamente a lo largo de la asignatura para ubicarnos y ver si estamos trabajando en el directorio correcto (normalmente nuestra carpeta clonada de Github) que contenga los archivos a los que necesitemos acceder o donde queramos crear nuevos. El comando nos devuelve la ruta (en mi caso, en el ejemplo anterior, "/mnt/c/Users/Raquel Suárez Gago/Mis Documentos/PERIHUM/2do cuatri/Periodismo de Datos/RaquelSG99", usamos las comillas para evitar problemas con espacios y otros caracteres).
- `ls`: list. Nos "lista" (nombra) el contenido del directorio en el que nos encontremos: los documentos o carpetas que contenga y a los que podemos seguir acccediendo partiendo de esa ruta. Es muy útil para llegar al directorio final al que queramos llegar paso a paso (por ejemplo, en el caso anterior, si yo estoy en "/mnt/c/Users/Raquel Suárez Gago/Mis Documentos/PERIHUM/2do cuatri/Periodismo de datos/RaquelSG99" puedo hacer `ls`y veré que esa carpeta contiene todas mis prácticas de la asignatura, que puedo abrir con el comando que explicaremos justo a continuación). También es útil para comprobar que algo se ha descargado o copiado bien (podríamos hacerlo después de usar el comando `cp` que explicaremos en otro momento). Este comando también tiene la opción `-l`, una versión "larga" del listado que especifica algunas de sus características.
- `cd`: change directory. Sirve, como su propio nombre indica, para cambiar de directorio respecto al directorio de trabajo (lo sabemos con `pwd`) en el que estemos previamente. Hay que tener en cuenta la estructura arborea, por eso es importante usar `ls` para ver que argumentos podemos añadir a `cd` dentro de la ruta en la que estamos.
- `mkdir`: make directory. Con este comando creamos un nuevo directorio (carpeta). El argumento que le sigue será el nombre de ese nuevo directorio. Por ejemplo hicimos `mkdir github` para crear una carpeta dentro de la ruta "/mnt/c/Users/Raquel Suárez Gago/Mis Documentos/PERIHUM/2do cuatri/Periodismo de datos" donde guardar nuestras primeras prácticas hasta que aprendimos a vincular el ordenador con github (yo, personalmente, después la eliminé y cloné el repositorio de Github directamente en el directorio "Periodismo de datos" para no alargar más la ruta). con `&&`se pueden ejecutar dos comandos sucesivos. Cuando creamos el directorio "github" hicimos `mkdir github && cd github`para que nos cambiase a ese directorio y que seguir trabajando en él.
- `cat`: concatenar. Permite crear fusionar e imprimir archivos para visualizarlos en pantalla. Lo usamos antes de tener nano para editar nuestros textos.
- `nano`: nano es un comando y un editor de texto que te permite crear y modificar archivos. El argumento es el nombre del archivo que vamos a crear o modificar si ya existía (en este caso, se tiene que ubicar en la ruta de nuestro directorio de trabajo). Trabajamos con markdown, que es importante que termine en ".md". Por ejemplo, para crear (y posteriormente editar) este documento que estoy escribiendo escribí `nano resumen.md`. 
- `mv`: move, mover. Los argumentos serán el origen y el destino. Traslada un archivo o directorio de una ruta a otra. Podemos usar un punto para indicar el lugar en el que estamos (lo sabemos con `pwd`, nos referimos a nuestro directorio de trabajo). Entre origen y destino dejamos un espacio en blanco y separamos todo con `/`porque trabajamos con rutas. Es decir, sería: `mv /origen/ /destino/`.Los archivos o directorios de origen desaparecen porque ahora se ubican en destino. 
- `cp`: copy, copiar. Igualmente, los argumentos son origen y destino, la estructura es la misma que para `mv`. Funciona como `mv`pero en este caso duplica lo que estamos copiando (es decir el archivo/carpeta se mantiene en origen). Es lo que hemos hecho cuando hemos clonado el nuevo repositorio dentro de "Pontedatos". Copimos las prácticas que habíamos realizado y teníamos guardadas en la carpeta clonada de nuestro repositorio en el perfil personal a la nueva carpeta clonada dentro de "Pontedatos".
- `git clone`: sirve para clonar un repositorio en remoto, de tal manera que queda vinculado con nuestro ordenador. Nosotros hemos clonado nuestro repositorio en Github (el del perfil personal y el de Pontedatos) para vincularlo con nuestro ordenador y editar/crear las prácticas con nano en el emulador de la terminal para después actualizarlas en Github desde este mismo. El argumento del comando es el link del repositorio que queremos clonar. Se crea en nuestro ordenador una "copia" (en el directorio de trabajo en el que ejecutamos el comando) de aquello que hemos clonado. Con los comandos que explicaremos a continuación es con los que los cambios que hacemos desde la terminal se actualizan en la url del repositorio clonado.
- `git add`: añadir. Este comando añade los cambios que hemos realizado en remoto para su posterior actualización en Github. Como argumento, tenemos que especificar qué queremos exactamente que se añada (nombre del/de los archivo/s). Nosotros solemos utilizar ` .` para indicar que queremos añadir los cambios de los archivos del directorio de trabajo en el que estamos en ese momento (ya que todo lo hacemos en su carpeta correspondiente). Lo haremos, por ejemplo, una vez terminado de redactar este mismo documento para vincularlo a nuestro repositorio en Pontedatos (igual que los dos pasos siguientes). 
- `git commit`: guarda lo que hemos añadido con git add; es el siguiente paso previo a actualizar los cambios en Github. Lo acompañamos de la opción `-m` de "message", mensaje, para indicar en qué consiste el cambio que hemos realizado. El argumento será (entrecomillas si usamos espacios, tildes, etc. para evitar errores) el nombre que damos a ese cambio. Por ejemplo, uno de mis últimos commits ha sido corregir algunos errores que había cometido en la práctica 3, así que tras editarlos con nano y hacer `git add .` hice git commit con `git commit -m 'cooreccion-p3'`. 
- `git push`: git push es el último paso para actualizar los cambios en Github (push, "empujar" es porque manda esos cambios a la url vinculada). Simplemente tenemos que ejecutar el comando. Nos pedirá nuestro usuario (RaquelSG99) y contraseña (un token que tenemos que generar previamente) para ejecutarlo.
- `git status`: nos informa de cuál es el estado de nuestro git si estamos perdidos en los pasos anteriores. Si se han guardado cambios, pero falta commitear, si ya está todo listo para ejecutar `git push`, cuáles son los cambios en remoto que no se han vinculado a la web... 
